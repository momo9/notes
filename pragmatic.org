* 哲学
- 别说不行，别找借口，给理由，给方案
- 别留下破窗
- 带头做事，激发斗志
- 多和用户聊聊他们的需求，他们常常更想要现在的有bug版本，而不是未来的完美版本
- 持续学习不同的东西
- 说听众爱听的，能听懂的东西，多通过语言与文档来沟通
* 方法
- DRY，重复的东西难以维护， *使用代码生成器*
- 每个模块各司其职，减少耦合
- 情况随时都会有变化，设计的架构把变化考虑在内，而不是情况一变化就需要重来
- 曳光弹，先有可运行的简陋系统，再一步步地根据运行情况改进（敏捷开发）
- 原型，有点像曳光弹，但它只是一种模拟，作用不是用来被改进，而是实验（比如精益创业）
- 不只是编程序解决问题，可以为特定问题实现一种简单的语言
- 对结果进行估算
* 工具
- 使用易读的纯文本配置项，并用python、awk等进行处理
- 用shell处理批量任务
- 用好一种编辑器
- 源码控制
- bug总是存在，不要追究责任，重点是修复bug
- *多怀疑自己的程序，并用像别人讲解的方式来找bug*
* 偏执
- 不可能bug free，永远要谨慎
- 按合约设计，不符合合约的就报错
  - 前条件
  - 后条件
  - 循环不变项
- 尽早让有问题的程序直接死掉
- 一切都有可能，如果有些情况确实不该发生，就用断言保证它不会发生
- 只在确实是异常情况时用异常，不要用异常处理正常的情况
- 分配了资源一定要释放，如果不好追踪，可以自己实现引用计数
* 让代码不过时
- 通过分层来解耦，把用户需要的东西以接口的方式提供给他， *不让用户跨层调用* （但偶尔也通过违反这个法则来提升性能）
- 使用run-time的元数据（properties，xml等）， *代码负责抽象，细节则在元数据中*
- 考虑并发，考虑接触时间上的耦合，改善工作流，让能够并行的流程并行完成
- *服务：* 具有统一接口的，独立、并发的对象
* 编码
- 不要受已有编码的束缚， *该重构时就重构*
- 重构
  - 不要在重构时加入新功能
  - 修改要有破坏性，让旧的代码直接无法通过编译
  - 单元测试测完不要扔，这样重构了以后就可以自动化的验证是否有错误
- 测试
  - 面向测试进行设计
  - 日志
  - 调试用的热键
* 开始之前
- 需求要深挖，真正的需求和用户表述的根本不一致， *通常更抽象*
- *成为用户* 来挖掘需求
- 做出原型让用户使用
- 许多项目的失败是因为项目范围的增大
- 面对难题
  - 列出所有可能的解决方案，不要局限在一个思路里， *好的解决方案可能是之前被认为不可能的方案*
  - 遇到太麻烦的答案时，再想想看，一定还有更好的解决方案
  - 对需求的重新诠释能让问题全部消失
- 不想干活不一定是拖延症，也可能是直觉让你感觉方案有问题， *做出原型来验证自己的疑惑*
- 需求、规范、开发、测试之间不是独立的，应该相互反馈
* 项目
- 启动项目时，取一个犀利的名字
- 自动化的项目编译、回归测试、文档生成
- 编一点、测一点
- 回归测试：确保今天的修改没有破坏之前的代码
- 修改bug后，应该在自动化测试中保留对这个bug的测试， *因为它会再次出现*
- *文档应该仅仅作为代码的一个view* ，而不是独立存在
- *不符合用户预期的产品是失败的，不管绝对意义上有多好*
- 稍稍超出用户预期

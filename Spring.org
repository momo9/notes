* 处理流程

- web.xml中，映射一个 =DispatcherServlet= ，假设名字为 =ctrl=
- 建一个 =ctrl-servlet.xml= ，对 =ctrl= 进行配置
- 配置好 =<mvc:annotation-driven/>= ，就会自动去找 =@Controller= （可以有多个）
- controller 里再根据 url 等进行处理，可以直接返回 POJO （简单的 Bean），默认转换为 JSON

* REST

_在 url 中反映出请求的内容_

- level 0：只有一个 url，请求内容都在报文中
- level 1：不同的服务在不同的 url 中，但相关参数在报文中
- level 2：服务与参数都在报文中
- level 3：请求与 level 2 一样，但响应中包括了可能需要访问的 url，用户完全不需要知道服务的结构是怎样的

* annotation

- 在 spring 中，主要是代替配置
- =@RequestBody= 主要处理 =application/json= 与 =application/xml=
- 用 =@ResponseStatus= 标注异常，当异常发生时就会抛出相应的状态码（如 404）

* 单元测试

- spring 的单元测试可以模拟 HTTP 请求，并测试状态码
- spring 使用 =HttpMessageConverter= 在 POJO 与 JSON 间转换

* @Autowired（初步理解）

- 标注方法或是构造器：作为 setter、getter 使用
- 标注字段：去某些作用域中寻找该字段对应的对象（只能是单例）

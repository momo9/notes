* 处理流程

- controller
  - web.xml中，映射一个 =DispatcherServlet= ，假设名字为 =ctrl=
  - 建一个 =ctrl-servlet.xml= ，对 =ctrl= 进行配置（就是一般应用中的 =applicationContext.xml= ）
  - 配置好 =<mvc:annotation-driven/>= ，就会自动去找 =@Controller= （可以有多个， =Controller= 其实是一种 =Component= ，annotation-driven 的作用之一是开启 component-scan）
  - controller 里再根据 url 等进行处理
    - 可以是服务，直接返回 POJO （简单的 Bean），被封装为 json、xml 等形式
    - 可以修改 model，传递给 view 显示（通过返回字符串确定具体的 view）
- view
  - 在 =*-servlet.xml= 中设置好模板引擎
  - 将模板放置在正确的路径下即可
- json
  - 部署了 =jackson-databind=
  - 配置了 =<mvc:annotation-driven />=
  - 标注了 =@ResponseBody= 的方法返回 POJO 就能够被封装为 json

* REST

_在 url 中反映出请求的内容，或者说建立 url 与后端 method 的对应关系_

- level 0：只有一个 url，请求内容都在报文中
- level 1：不同的服务在不同的 url 中，但相关参数在报文中
- level 2：服务与参数都在报文中
- level 3：请求与 level 2 一样，但响应中包括了可能需要访问的 url，用户完全不需要知道服务的结构是怎样的
  例子
  #+begin_src
  {
    bookmark: {
      id: 3,
      uri: "http://bookmark.com/1/dsyer",
      description: "A description"
    },
    links: [
      {
        rel: "bookmark-uri",
        href: "http://bookmark.com/1/dsyer"
      },
      {
        rel: "bookmarks",
        href: "http://localhost:8080/dsyer/bookmarks"
      },
      {
        rel: "self",
        href: "http://localhost:8080/dsyer/bookmarks/3"
      }
    ]
  }
  #+end_src

* annotation

- 在 spring 中，主要是代替配置
- =@RequestBody= 主要处理 =application/json= 与 =application/xml=
- 用 =@ResponseStatus= 标注异常，当异常发生时就会抛出相应的状态码（如 404）

* 单元测试

- spring 的单元测试可以模拟 HTTP 请求，并测试状态码
- spring 使用 =HttpMessageConverter= 在 POJO 与 JSON 间转换

* 依赖注入

或者叫控制反转。在原本的过程中，如果 A 依赖 B，就必须得先定义好 B。现在是 A 依赖一个 B 的接口，具体什么是 B 是不清楚的。到 B 建立的时候，再把自己注入进去，实现了依赖的反转。

=ApplicationContext= 就是生成 bean 的工厂。

** constructor-based or setter-based

- mandatory: constructor-based
- optional: setter-based

** @Autowired

标注了 =@Autowired= 以后，可以省略一些配置，改为从已有的 bean 中寻找相应的对象（根据类型来匹配）

- 标注字段：不需要 setter 和 xml 中的 property
- 标注构造器：不需要 xml 中的 constructor-arg
- 标注 setter 与 getter：不需要 xml 中的 property

如果有多个匹配类型的 bean，会报错；这时可以通过 =@Qualifier= 来指定 bean

** 作用域

如果全局作用域的 bean 作为生存期较短的 bean 的依赖，则需要用到 aop-proxy

** web 应用中如何加载 spring 配置

- 在 =web.xml= 中加入相应的 =Listener=
- 配置文件为 =WEB-INF= 中的 =applicationContext.xml=

** @Component

- 标注了 =@Component= 的类将成为 bean
- 配置中需要有 =<context:component-scan>=

** 获取 bean

通过 =WebApplicationContextUtils= 获取 context，再从 context 中获取 bean

* AOP

OOP 通过对象间的关系来进行抽象，好比是树状结构。然而，有些行为是各个对象都具有的，好比标签一样，不便用 OOP 来描述，这时就需要 AOP。

Spring 的 AOP 是简单的 AOP，以方法作为切入点，在匹配的切入点上进行操作。

- 需要标注 =@Aspect= 的 bean 来定义 aspect
  - =@Pointcut= 用于定义切入点，包括匹配方法的表达式以及签名（切入点的标识）
  - =@Before= 、 =@AfterReturning= 等用于定义在切入点进行的行为
- 配置文件中需要加入 =<aop:aspectj-autoproxy>=

* DAO

** JDBC

- POJO
- DAO 接口
- DAO 实现
  - =JdbcTemplate= （依赖单例的 =DriverManagerDataSource= ，但 =JdbcTemplate= 本身不是单例）
  - 一个对应请求结果和 POJO 的 Mapper（实现 =RowMapper= )

** Hibernate

- Hibernate 的同时也需要 JDBC
- 定义 =LocalSessionFactoryBean= ，通过这个 bean 设置 Hibernate
- *.hbm.xml
  - 定义 ORM 关系
  - =id= 对应主键， =generator= 选 =native=
  - DDL 语句支持得并不好
- 同时， =LocalSessionFactoryBean= 其实可以看作是 =SessionFactory= 的 bean，用于生成 =Session=
- =Session= 的操作
  - =save()= ，参数为 POJO
  - 建立 =Criteria= 确定查询的条件， =list()= 得到查询结果

** MyBatis

- POJO 必须实现 =Serializable=
- =SqlSessionFactoryBean= bean，用于配置 MyBatis
- Mapper
  - 开启 =<mybatis:scan />= ，自动扫描 Mapper 成为 bean
  - Mapper 是一个 =interface= ，类名与 xml 中的 =namespace= 对应，方法与查询的 =id= 对应
  - DAO 中通过调用 Mapper 的方法来执行相应 id 中的 SQL 语句
